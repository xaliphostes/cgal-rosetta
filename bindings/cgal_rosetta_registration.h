// ============================================================================
// cgal Library Rosetta Registration
// ============================================================================
// Generated by rosetta-create
//
// This file registers cgal classes with Rosetta for introspection.
//
// IMPORTANT: For overloaded functions, use FULLY QUALIFIED type names
// because the macro stringifies the type and it must be valid C++ in the
// generated binding file.
// ============================================================================
#pragma once

#include <rosetta/rosetta.h>

// TODO: Add your library headers here
#include <CGAL/Bbox_3.h>
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/IO/polygon_mesh_io.h>
#include <CGAL/Polygon_mesh_processing/clip.h>                 // split()
#include <CGAL/Polygon_mesh_processing/connected_components.h> // split_connected_components()
#include <CGAL/Polygon_mesh_processing/corefinement.h>         // corefine()
#include <CGAL/Polygon_mesh_processing/intersection.h>         // (optionnel) do_intersect
#include <CGAL/Polygon_mesh_processing/remesh.h>               // isotropic_remeshing()
#include <CGAL/Polygon_mesh_processing/self_intersections.h>   // does_self_intersect()
#include <CGAL/Polygon_mesh_processing/triangulate_faces.h>
#include <CGAL/Surface_mesh.h>
#include <CGAL/box_intersection_d.h> // box_intersection_d()
#include <set>
#include <tuple>

namespace PMP    = CGAL::Polygon_mesh_processing;
namespace params = CGAL::parameters;

using K     = CGAL::Exact_predicates_inexact_constructions_kernel;
using Mesh  = CGAL::Surface_mesh<K::Point_3>;
using Part  = std::vector<Mesh>;
using Parts = std::tuple<std::vector<Mesh>, std::vector<Mesh>>;

Mesh loadMesh(const std::string &filename) {
    Mesh A;
    if (!CGAL::IO::read_polygon_mesh(filename, A) || A.is_empty()) {
        std::cerr << "Cannot read mesh from " << filename << std::endl;
        return {};
    }
    return A;
}

void saveParts(const std::vector<Mesh> &parts, const std::string &name,
               const std::string &extension) {
    for (std::size_t i = 0; i < parts.size(); ++i) {
        std::string filename = name + "_" + std::to_string(i) + "." + extension;
        CGAL::IO::write_polygon_mesh(filename, parts[i]);
    }
}

void saveMesh(const Mesh &mesh, const std::string &filename) {
    CGAL::IO::write_polygon_mesh(filename, mesh);
}

Parts intersect(const Mesh &A_in, const Mesh &B_in) {
    // Make copies since split() modifies the meshes
    Mesh A = A_in;
    Mesh B = B_in;

    // Pré-requis pratiques : que les surfaces soient triangulées
    // PMP::triangulate_faces(A);
    // PMP::triangulate_faces(B);

    // Précondition (très recommandé) : pas d'auto-intersections pour les surfaces
    // (split/corefine ont comme précondition !does_self_intersect)
    if (PMP::does_self_intersect(A) || PMP::does_self_intersect(B)) {
        std::cerr << "Au moins un maillage s'auto-intersecte -> nettoyer avant.\n";
        return {};
    }

    // Optionnel : éviter de faire du boulot inutile
    if (!PMP::do_intersect(A, B)) {
        std::cerr << "Pas d'intersection.\n";
        return {};
    }

    // 1) Couper A par B (A reçoit les frontières d'intersection)
    PMP::split(A, B, params::throw_on_self_intersection(true),
               params::default_values()); // np_s

    // 2) Couper B par A : ATTENTION split() modifie le 'splitter' (B ci-dessus
    // a déjà été modifié).
    //    Pour éviter de remodifier A, on passe do_not_modify(true) côté
    //    splitter.
    PMP::split(B, A, params::throw_on_self_intersection(true), params::do_not_modify(true));

    // 3) Extraire les morceaux (1 mesh par composante connexe)
    std::vector<Mesh> partsA, partsB;
    PMP::split_connected_components(A, partsA);
    PMP::split_connected_components(B, partsB);

    return {partsA, partsB};
}

// ============================================================================
// Remesh a surface mesh using isotropic remeshing
// ============================================================================
Mesh remesh(const Mesh &mesh_in, double target_edge_length, unsigned int nb_iter = 3) {
    Mesh mesh = mesh_in;

    // Ensure mesh is triangulated
    PMP::triangulate_faces(mesh);

    // Get all faces for remeshing
    PMP::isotropic_remeshing(faces(mesh), target_edge_length, mesh,
                             params::number_of_iterations(nb_iter));

    return mesh;
}

// ============================================================================
// Remesh a pair of corefined meshes while preserving intersection edges
// ============================================================================
using RemeshPairResult = std::tuple<Mesh, Mesh>;

/**
 * @brief Remeshes two corefined meshes while preserving their intersection curve.
 * After corefinement, both meshes share coincident vertices along intersection curves.
 * This function identifies those shared vertices and protects the edges connecting them
 * during remeshing.
 *
 * @param mesh_a First corefined mesh
 * @param mesh_b Second corefined mesh
 * @param target_edge_length Target edge length for remeshing
 * @param nb_iter Number of remeshing iterations
 * @param tolerance Tolerance for identifying coincident vertices (default: 1e-10)
 * @return Pair of remeshed meshes with preserved intersection curve
 */
RemeshPairResult remeshPair(const Mesh &mesh_a_in, const Mesh &mesh_b_in,
                            double target_edge_length, unsigned int nb_iter = 3,
                            double tolerance = 1e-10) {
    Mesh mesh_a = mesh_a_in;
    Mesh mesh_b = mesh_b_in;

    // Ensure meshes are triangulated
    PMP::triangulate_faces(mesh_a);
    PMP::triangulate_faces(mesh_b);

    // Build spatial index for mesh_b vertices to find coincident vertices
    std::map<Mesh::Vertex_index, Mesh::Vertex_index> coincident_vertices_a_to_b;

    // For each vertex in mesh_a, check if there's a coincident vertex in mesh_b
    double tol_sq = tolerance * tolerance;

    for (auto va : mesh_a.vertices()) {
        K::Point_3 pa = mesh_a.point(va);
        for (auto vb : mesh_b.vertices()) {
            K::Point_3 pb = mesh_b.point(vb);
            double dist_sq = CGAL::squared_distance(pa, pb);
            if (dist_sq < tol_sq) {
                coincident_vertices_a_to_b[va] = vb;
                break;
            }
        }
    }

    // Create edge constraint maps for both meshes
    auto ecm_a = mesh_a.add_property_map<Mesh::Edge_index, bool>("e:is_constrained", false).first;
    auto ecm_b = mesh_b.add_property_map<Mesh::Edge_index, bool>("e:is_constrained", false).first;

    // Mark edges in mesh_a where both endpoints are coincident with mesh_b
    for (auto ea : mesh_a.edges()) {
        auto ha = mesh_a.halfedge(ea);
        auto v0 = mesh_a.source(ha);
        auto v1 = mesh_a.target(ha);

        if (coincident_vertices_a_to_b.count(v0) && coincident_vertices_a_to_b.count(v1)) {
            ecm_a[ea] = true;
        }
    }

    // Build reverse map for mesh_b
    std::set<Mesh::Vertex_index> coincident_vertices_b;
    for (const auto &pair : coincident_vertices_a_to_b) {
        coincident_vertices_b.insert(pair.second);
    }

    // Mark edges in mesh_b where both endpoints are coincident with mesh_a
    for (auto eb : mesh_b.edges()) {
        auto hb = mesh_b.halfedge(eb);
        auto v0 = mesh_b.source(hb);
        auto v1 = mesh_b.target(hb);

        if (coincident_vertices_b.count(v0) && coincident_vertices_b.count(v1)) {
            ecm_b[eb] = true;
        }
    }

    // Count constrained edges for debugging
    int constrained_a = 0, constrained_b = 0;
    for (auto ea : mesh_a.edges()) if (ecm_a[ea]) constrained_a++;
    for (auto eb : mesh_b.edges()) if (ecm_b[eb]) constrained_b++;
    std::cout << "  Constrained edges: mesh_a=" << constrained_a << ", mesh_b=" << constrained_b << std::endl;

    // Remesh both meshes with edge constraints protected
    PMP::isotropic_remeshing(faces(mesh_a), target_edge_length, mesh_a,
                             params::number_of_iterations(nb_iter)
                             .edge_is_constrained_map(ecm_a)
                             .protect_constraints(true));

    PMP::isotropic_remeshing(faces(mesh_b), target_edge_length, mesh_b,
                             params::number_of_iterations(nb_iter)
                             .edge_is_constrained_map(ecm_b)
                             .protect_constraints(true));

    // Clean up property maps
    mesh_a.remove_property_map(ecm_a);
    mesh_b.remove_property_map(ecm_b);

    return {mesh_a, mesh_b};
}

// ============================================================================
// Intersect and remesh a pair of meshes
// ============================================================================
/**
 * @brief Corefines two meshes and then remeshes them while preserving the intersection.
 * This is a convenience function that combines corefinement and constrained remeshing.
 *
 * @param mesh_a First mesh
 * @param mesh_b Second mesh
 * @param target_edge_length Target edge length for remeshing
 * @param nb_iter Number of remeshing iterations
 * @return Pair of corefined and remeshed meshes, or empty meshes if no intersection
 */
RemeshPairResult intersectAndRemeshPair(const Mesh &mesh_a_in, const Mesh &mesh_b_in,
                                        double target_edge_length, unsigned int nb_iter = 3) {
    Mesh mesh_a = mesh_a_in;
    Mesh mesh_b = mesh_b_in;

    // Check for self-intersections
    if (PMP::does_self_intersect(mesh_a) || PMP::does_self_intersect(mesh_b)) {
        std::cerr << "At least one mesh has self-intersections -> clean before.\n";
        return {{}, {}};
    }

    // Check if meshes actually intersect
    if (!PMP::do_intersect(mesh_a, mesh_b)) {
        std::cerr << "Meshes do not intersect.\n";
        return {mesh_a, mesh_b};
    }

    // Corefine the meshes
    PMP::corefine(mesh_a, mesh_b);

    // Remesh with constraints
    return remeshPair(mesh_a, mesh_b, target_edge_length, nb_iter);
}

// ============================================================================
// Intersect N surfaces optimally using bounding box filtering
// Returns a vector of mesh pairs (indices) that intersect, plus the modified meshes
// ============================================================================
using IntersectionPair   = std::pair<std::size_t, std::size_t>;
using IntersectionResult = std::tuple<std::vector<Mesh>, std::vector<IntersectionPair>>;

// Box type for intersection detection
struct MeshBox {
    CGAL::Bbox_3 bbox;
    std::size_t  index;

    MeshBox(const CGAL::Bbox_3 &b, std::size_t i) : bbox(b), index(i) {}

    // Required by Box_intersection_d
    const CGAL::Bbox_3 &bbox_3() const { return bbox; }
    std::size_t         id() const { return index; }
};

/**
 * @brief Handles n surfaces with optimized intersection detection:
 * - Uses bounding box filtering to avoid O(n²) exact tests
 * - Corefines intersecting pairs so they share coincident nodes at intersection curves
 * - Returns modified meshes + list of intersecting pairs
 * @return tuple<vector<Mesh>, vector<pair<size_t, size_t>>>
 */
IntersectionResult intersectN(const std::vector<Mesh> &meshes_in) {
    if (meshes_in.size() < 2) {
        return {meshes_in, {}};
    }

    // Make copies of meshes
    std::vector<Mesh> meshes = meshes_in;

    // Check for self-intersections
    for (std::size_t i = 0; i < meshes.size(); ++i) {
        if (PMP::does_self_intersect(meshes[i])) {
            std::cerr << "Mesh " << i << " has self-intersections -> clean before.\n";
            return {{}, {}};
        }
    }

    // Create bounding boxes for each mesh
    std::vector<MeshBox> boxes;
    boxes.reserve(meshes.size());
    for (std::size_t i = 0; i < meshes.size(); ++i) {
        boxes.emplace_back(PMP::bbox(meshes[i]), i);
    }

    // Find all pairs of potentially intersecting meshes using bounding boxes
    std::set<IntersectionPair> candidate_pairs;

    // O(n^2) check on bounding boxes (fast for typical mesh counts)
    // For very large n, could use CGAL::box_self_intersection_d
    for (std::size_t i = 0; i < boxes.size(); ++i) {
        for (std::size_t j = i + 1; j < boxes.size(); ++j) {
            if (CGAL::do_overlap(boxes[i].bbox, boxes[j].bbox)) {
                // Bounding boxes overlap, check actual intersection
                if (PMP::do_intersect(meshes[i], meshes[j])) {
                    candidate_pairs.insert({i, j});
                }
            }
        }
    }

    // Convert to vector
    std::vector<IntersectionPair> intersecting_pairs(candidate_pairs.begin(),
                                                     candidate_pairs.end());

    if (intersecting_pairs.empty()) {
        std::cerr << "No intersections found among " << meshes.size() << " meshes.\n";
        return {meshes, {}};
    }

    // Process each intersecting pair: corefine them so they share nodes at intersections
    // We need to track which meshes have been modified to avoid redundant work
    std::vector<bool> modified(meshes.size(), false);

    for (const auto &pair : intersecting_pairs) {
        std::size_t i = pair.first;
        std::size_t j = pair.second;

        // Corefine the two meshes so they share vertices at intersection curves
        PMP::corefine(meshes[i], meshes[j]);
        modified[i] = true;
        modified[j] = true;
    }

    return {meshes, intersecting_pairs};
}

// ============================================================================
// Split N surfaces and return all parts
// ============================================================================
using SplitNResult = std::tuple<std::vector<Mesh>, std::vector<IntersectionPair>>;

/**
 * @brief Splits n surfaces at all intersections:
 * - Same bounding box optimization
 * - Splits all intersecting pairs
 * - Returns all connected components from all meshes
 * @return tuple<vector<Mesh>, vector<pair<size_t, size_t>>>
 */
SplitNResult splitN(const std::vector<Mesh> &meshes_in) {
    if (meshes_in.size() < 2) {
        return {meshes_in, {}};
    }

    // Make copies of meshes
    std::vector<Mesh> meshes = meshes_in;

    // Check for self-intersections
    for (std::size_t i = 0; i < meshes.size(); ++i) {
        if (PMP::does_self_intersect(meshes[i])) {
            std::cerr << "Mesh " << i << " has self-intersections -> clean before.\n";
            return {{}, {}};
        }
    }

    // Create bounding boxes for each mesh
    std::vector<MeshBox> boxes;
    boxes.reserve(meshes.size());
    for (std::size_t i = 0; i < meshes.size(); ++i) {
        boxes.emplace_back(PMP::bbox(meshes[i]), i);
    }

    // Find all pairs of potentially intersecting meshes
    std::set<IntersectionPair> candidate_pairs;
    for (std::size_t i = 0; i < boxes.size(); ++i) {
        for (std::size_t j = i + 1; j < boxes.size(); ++j) {
            if (CGAL::do_overlap(boxes[i].bbox, boxes[j].bbox)) {
                if (PMP::do_intersect(meshes[i], meshes[j])) {
                    candidate_pairs.insert({i, j});
                }
            }
        }
    }

    std::vector<IntersectionPair> intersecting_pairs(candidate_pairs.begin(),
                                                     candidate_pairs.end());

    if (intersecting_pairs.empty()) {
        std::cerr << "No intersections found among " << meshes.size() << " meshes.\n";
        return {meshes, {}};
    }

    // Split each intersecting pair
    for (const auto &pair : intersecting_pairs) {
        std::size_t i = pair.first;
        std::size_t j = pair.second;

        // Split mesh i by mesh j
        PMP::split(meshes[i], meshes[j], params::throw_on_self_intersection(true),
                   params::default_values());

        // Split mesh j by mesh i (with do_not_modify for the splitter)
        PMP::split(meshes[j], meshes[i], params::throw_on_self_intersection(true),
                   params::do_not_modify(true));
    }

    // Extract all connected components from all meshes
    std::vector<Mesh> all_parts;
    for (auto &mesh : meshes) {
        std::vector<Mesh> parts;
        PMP::split_connected_components(mesh, parts);
        all_parts.insert(all_parts.end(), parts.begin(), parts.end());
    }

    return {all_parts, intersecting_pairs};
}

namespace cgal_rosetta {

    inline void register_all() {
        ROSETTA_REGISTER_CLASS(Mesh);
        ROSETTA_REGISTER_FUNCTION(loadMesh);
        ROSETTA_REGISTER_FUNCTION(saveMesh);
        ROSETTA_REGISTER_FUNCTION(saveParts);
        ROSETTA_REGISTER_FUNCTION(intersect);
        ROSETTA_REGISTER_FUNCTION(remesh);
        ROSETTA_REGISTER_FUNCTION(remeshPair);
        ROSETTA_REGISTER_FUNCTION(intersectAndRemeshPair); 
        ROSETTA_REGISTER_FUNCTION(intersectN);
        ROSETTA_REGISTER_FUNCTION(splitN);
    }

} // namespace cgal_rosetta
